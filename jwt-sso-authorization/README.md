
# JWT (JSON Web Tokens)

## Информационная безопасность

- Регистрация
- Разграничение доступа
  - Получение конфиденциальных данных
  - Совершение привилегированных действий
  - Свой профиль
- Протоколирование и аудит
  - История действий
- Администрирование и управление ролями

----

## Разграничение доступа

Тварь я дрожащая, или право имею?

```mermaid
flowchart LR

req[[Запрос]]-->|"я хочу страницу /page/1<br>вот мои данные (идентификация)"|auth[Аутентификация.<br>Кто это на самом деле?]

subgraph сервер

auth-->|это Виталик|permit[Авторизация.<br>Право имеет?]

permit-->|у Виталика есть права|Успех
permit-->|у Виталика нет прав|Отказ

end

auth-->|это неизвестно кто|login([страница login])
Успех-->page([страница /page/1])
Отказ-->login
```

----

## Вариант №1: Авторизация по логину-паролю:

```mermaid
sequenceDiagram
    actor C as Браузер (фронтенд)
    participant S as Веб-сервер (бэкенд)

    note right of C: Клиент не аутентифицирован.

    C->>+S: GET /page/1
    S-->>-C: 401 (Unauthorized), <login form>

    note right of C: Клиент аутентифицирован.

    C->>+S: GET /page/1, login, password
    S-->>-C: 200, <page 1>

    loop Для каждой N-ной страницы
        C->>+S: GET /page/N, login, password
        S-->>-C: 200, <page N>
    end

    note right of C: Клиент не аутентифицирован.

    C->>+S: GET /page/9
    S-->>-C: 401 (Unauthorized), <login form>
```

Минусы:
 - Браузер хранит пароль и передаёт в каждом запросе
 - Зная пароль, злоумышленник может незаметно им пользоваться
 - Нельзя закрыть доступ злоумышленнику, не изменив пароль
 - Не получится менять пароль достаточно часто

----

## Вариант №2: Сессия пользователя

Суть решения — разделить идентификационные данные (credentials) и токен авторизации. Для авторизации используется временный session-id.

```mermaid
sequenceDiagram
    actor C as Браузер (фронтенд)
    participant S as Веб-сервер (бэкенд)
    participant D as СУБД

    note right of C: Клиент не аутентифицирован.

    C->>+S: GET /page/1
    S-->>-C: 401 (Unauthorized), <login form>

    C->>+S: POST /login, login, password
    S->>D: сохранить session-id
    S-->>-C: 200, session-id

    note right of C: Клиент аутентифицирован.

    C->>+S: GET /page/1, session-id
    D->>S: получить session-id
    S-->>-C: 200, <page 1>

    loop Для каждой N-ной страницы
        C->>+S: GET /page/N, session-id
        D->>S: получить session-id
        S-->>-C: 200, <page N>
    end

    C->>+S: POST /logout
    S->>D: удалить session-id

    note right of C: Клиент не аутентифицирован.

    S-->>-C: 401 (Unauthorized), <login form>
```

Минусы:
 - При смене сессии нужно заново отправлять пароль
 - Проблемы масштабирования

----

## Вариант №3: JWT (RFC 7519)

Суть решения — автоматическая смена токена авторизации.

После аутентификации клиент получает два токена — Access Token и Refresh Token. Access Token используется как session-id и так же ограничен по времени.

```mermaid
sequenceDiagram
    actor C as Браузер (фронтенд)
    participant S as Веб-сервер (бэкенд)

    note right of C: Клиент не аутентифицирован.

    C->>+S: GET /page/1
    S-->>-C: 401 (Unauthorized), <login form>

    C->>+S: POST /login, login, password
    S-->>-C: 200, AccessToken, RefreshToken

    note right of C: Клиент аутентифицирован.

    C->>+S: GET /page/1, AccessToken
    S-->>-C: 200, <page 1>
```

Refresh Token одноразовый, используется для обновления Access Token'а.

```mermaid
sequenceDiagram
    actor C as Браузер (фронтенд)
    participant S as Веб-сервер (бэкенд)

    C->>+S: GET /page/1, AccessToken
    S-->>-C: 401 Unauthorized

    note right of C: Обновление токенов

    C->>+S: POST /refresh, RefreshToken
    S-->>-C: 200, AccessToken, RefreshToken новые

    C->>+S: GET /page/1, AccessToken новый
    S-->>-C: 200, <page>
```

Реализация: своя либо библиотека, например https://auth0.com/


## Криптография и масштабирование

Важная особенность — токен это JSON с идентификатором пользователя, подписанный криптографической подписью. Никакие секретные ключи в запросах не передаются.

Формат токена — строка `{заголовок}.{тело}.подпись`, закодированная в base64.

Пример: https://jwt.io/

Проверить через https://www.base64decode.org/

Тело хранит идентификатор пользователя и время действия токена, а подпись гарантирует подлинность. Криптография даёт возможность не хранить токен в БД, как id сессии, а проверять валидность токена распределённо.

Токен кодируется в base64, чтобы упростить его хранение и передачу в виде текста.

На клиенте токен хранится в куки или в локальном хранилище браузера:
 - Хранение в локальном хранилище дает доступ к токену клиенту, это и плюс и минус (уязвимость к CSRF).
 - Хранение в httpOnly кукис не даёт возможности прочитать токен из скриптов на стороне фронтенда.


# SSO (Single sign-on)

"Технология единого входа". Решаемая проблема — хранение и передача идентификационных данных. Суть решения — делегировать задачу аутентификации стороннему провайдеру.

Для пользователя не всегда понятно, когда применялось SSO. Пример с VK Connect. Сторонний провайдер также может предоставлять другие способы проверки подлинности (например, смс на телефон).


## Пример внедрения OAuth

<img src="https://testit.software/themes/ino-testit/assets/images/logo/logo.svg" width="300px">

https://testit.software/


Изначально разграничение доступа было сделано через JWT. После чего добавлена аутентификация через OpenID Connect (слой аутентификации в OAuth 2.0).

- Основная работа на стороне бэкенда
- Не работает без HTTPS
- В аккаунт зайти как по OpenID, так и просто с логином-паролем

Как выглядит для администратора системы:

1. Настроить подключение OpenID Connect (адрес провайдера, идентификатор, ключ), опционно иконку.
2. Указать данные о пользователях, которые получит приложение. Минимальный набор — OpenID, email, profile.

После этого у пользователей получается кнопка с иконкой, при нажатию на которую перенаправляет на веб-страницу провайдера аутентификации и затем обратно.

Также добавлена интеграция с Jira по OAuth 1.0.

Как выглядит для администратора системы:

1. В администрировании приложения берём публичный ключ
2. В Jira в настройках добавляем приложение, указываем там этот ключ
3. В приложении включаем интеграцию с Jira

Позволяет приложению создавать тикеты в Jira через api.

![](https://fjord.dropboxstatic.com/warp/conversion/dropbox/warp/en-us/Dropbox.svg)

Dropbox использует Oauth 2.0 https://developers.dropbox.com/oauth-guide

OAuth 2.0 — развитие версии 1.0, работать с протоколом стало проще.

![](https://developers.dropbox.com/cms/content/dam/dropbox/www/en-us/landing-pages/developers/oauth-guide/oauth2-diagram.png)



## Другие протоколы

```mermaid
graph

subgraph SSO
all[Протоколы аутентификации]
end
subgraph Только аутентификация
all ----> openid[OpenID Connect]
end

subgraph Аутентификация + api доступа к приватным данным
all ----> oauth[OAuth 1.0]
openid ----> oauth2[OAuth 2.0]
all ----> WebAuthn
end

subgraph Единый каталог
all -.-> ldap[LDAP]
end
```

OpenID — только аутентификация для пользователя.

LDAP — централизованная директория аккаунтов; не подходит для сайтов в интернете.

OAuth/OAuth2 — аутентификация + может авторизировать действия приложения-клиента у провайдера (api)

WebAuthn — то же плюс поддержка большего количество средств аутентификации (напр. биометрия); другое название — Web Authentication API

Другие протоколы: SAML, Kerberos




