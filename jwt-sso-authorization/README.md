
## Информационная безопасность

- Регистрация
- Разграничение доступа
  - Получение конфиденциальных данных
  - Совершение привилегированных действий
  - Свой профиль
- Протоколирование и аудит
  - История действий
- Администрирование и управление ролями


## Разграничение доступа

Тварь я дрожащая, или право имею?

```mermaid
flowchart LR

req[[Запрос]]-->|я хочу страницу /page/1<br>вот мои данные|auth[Аутентификация.<br>Кто это?]

subgraph сервер

auth-->|это Виталик|permit[Авторизация.<br>Право имеет?]

permit-->|у Виталика есть права|Успех
permit-->|у Виталика нет прав|Отказ

end

auth-->|это неизвестно кто|login([страница login])
Успех-->page([страница /page/1])
Отказ-->login
```


## Вариант №1: Авторизация по логину-паролю:

```mermaid
sequenceDiagram
    actor C as Браузер (фронтенд)
    participant S as Веб-сервер (бэкенд)

    note right of C: Клиент не аутентифицирован.

    C->>+S: GET /page/1
    S-->>-C: 401 (Unauthorized), <login form>

    note right of C: Клиент аутентифицирован.

    C->>+S: GET /page/1, login, password
    S-->>-C: 200, <page 1>

    loop Для каждой N-ной страницы
        C->>+S: GET /page/N, login, password
        S-->>-C: 200, <page N>
    end

    note right of C: Клиент не аутентифицирован.

    C->>+S: GET /page/9
    S-->>-C: 401 (Unauthorized), <login form>
```

Минусы:
 - Пароль передается в каждом запросе
 - Зная пароль, злоумышленник может незаметно им пользоваться
 - Нельзя закрыть доступ злоумышленнику, не изменив пароль
 - Не получится менять пароль достаточно часто


## Вариант №2: Сессия пользователя

Суть решения — разделить идентификационные данные (credentials) и токен авторизации. Для авторизации используется временный session-id.

```mermaid
sequenceDiagram
    actor C as Браузер (фронтенд)
    participant S as Веб-сервер (бэкенд)
    participant D as СУБД

    note right of C: Клиент не аутентифицирован.

    C->>+S: GET /page/1
    S-->>-C: 401 (Unauthorized), <login form>

    C->>+S: GET /login, login, password
    S->>D: сохранить session-id
    S-->>-C: 200, session-id

    note right of C: Клиент аутентифицирован.

    C->>+S: GET /page/1, session-id
    D->>S: получить session-id
    S-->>-C: 200, <page 1>

    loop Для каждой N-ной страницы
        C->>+S: GET /page/N, session-id
        D->>S: получить session-id
        S-->>-C: 200, <page N>
    end

    C->>+S: GET /logout
    S->>D: удалить session-id

    note right of C: Клиент не аутентифицирован.

    S-->>-C: 401 (Unauthorized), <login form>
```

Минусы:
 - Проблемы масштабирования
 - При смене сессии нужно заново отправлять пароль


## Вариант №3: JWT (RFC 7519)

Суть решения — автоматическая смена токена авторизации.

Создаются два токена — Access Token и Refresh Token. Access Token используется как session-id и так же ограничен по времени. Refresh Token одноразовый, используется для обновления Access Token'а.